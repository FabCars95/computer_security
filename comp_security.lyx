#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
HRule}{
\backslash
rule{
\backslash
linewidth}{0.5mm}}
\end_layout

\begin_layout Plain Layout


\backslash
center
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
LARGE Politecnico di Milano}
\backslash

\backslash
[1.5cm] 
\backslash
textsc{
\backslash
Large Computer Security}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Short Summary}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\backslash
begin{flushleft} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Authors:}
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
textsc{FabC07} 
\backslash
newline 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft} 
\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

~
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\backslash
begin{flushright} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushright} 
\backslash
end{minipage}
\backslash

\backslash
[3cm]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename logo/logopm.svg
	width 5cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{gobble}
\end_layout

\begin_layout Plain Layout

{
\backslash
large 
\backslash
today}
\backslash

\backslash
[3cm]
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
tableofcontents{}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Fundamentals of cryptography
\end_layout

\begin_layout Subsection
One-time-pad
\end_layout

\begin_layout Itemize
XOR of a message m and a random key k of the same size of m: 
\begin_inset Formula $len(k)=len(m)$
\end_inset


\end_layout

\begin_layout Itemize
The key is pre-shared and consumed while writing.
 It can never be re-used again
\end_layout

\begin_layout Itemize
Very inconvenient and used only in special cases
\end_layout

\begin_layout Subsection
Symmetric encryption
\end_layout

\begin_layout Itemize
Use key K to encrypt plaintext in ciphertext.
 Use same key K to decrypt ciphertext in plaintext
\end_layout

\begin_layout Itemize
Two important concepts:
\end_layout

\begin_deeper
\begin_layout Itemize
Substitution: replacing each byte with another (e.g.
 Caesar cipher)
\end_layout

\begin_layout Itemize
Transposition: swapping the values of given bits (e.g.
 matrix)
\end_layout

\end_deeper
\begin_layout Subsection
Asymmetric encryption
\end_layout

\begin_layout Itemize
a cipher that uses two keys:
\end_layout

\begin_deeper
\begin_layout Itemize
What is encrypted with key1 can be decrypted only with key2 (and not with
 key1 itself), and viceversa
\end_layout

\begin_layout Itemize
The keys cannot be retrieved from each other
\end_layout

\end_deeper
\begin_layout Itemize
Diffie-Hellman Exchange algorithm:
\end_layout

\begin_deeper
\begin_layout Itemize
based on factorization problem
\end_layout

\begin_layout Itemize
Pick 
\begin_inset Formula $p$
\end_inset

 prime, 
\begin_inset Formula $a$
\end_inset

 primitive root of 
\begin_inset Formula $p$
\end_inset

, public (both Alice and Bob know)
\end_layout

\begin_layout Itemize
Pick a number 
\begin_inset Formula $X$
\end_inset

 in 
\begin_inset Formula $\left[1,\ldots,\right]\left(n-1\right)$
\end_inset

 (this is secret and is the private key of Alice 
\begin_inset Formula $X_{A}$
\end_inset

and Bob 
\begin_inset Formula $X_{B}$
\end_inset

)
\end_layout

\begin_layout Itemize
Obtain the public key as 
\begin_inset Formula $Y_{A}=\left(a^{X_{A}}\right)mod\left(p\right)$
\end_inset

 (for Alice) and 
\begin_inset Formula $Y_{B}=\left(a^{X_{B}}\right)mod\left(p\right)$
\end_inset

(for Bob) and exchange them
\end_layout

\begin_layout Itemize
Compute the common secret as 
\begin_inset Formula $K_{A}=\left(Y_{B}^{X_{A}}\right)mod\left(p\right)=K_{B}=\left(Y_{A}^{X_{B}}\right)mod\left(p\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
RSA algorithm:
\end_layout

\begin_deeper
\begin_layout Itemize
based on factorization problem
\end_layout

\begin_layout Itemize
Pick 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 two large primes
\end_layout

\begin_layout Itemize
Computing n = p * q is easy, but given n it is painfully slow to get p and
 q 
\end_layout

\begin_layout Itemize
Different problem than mod-log (D-H)
\end_layout

\begin_layout Itemize
At least 1024-bit key (typical choice are 2048-bit or 4096-bit)
\end_layout

\end_deeper
\begin_layout Subsection
Important notes
\end_layout

\begin_layout Itemize
Security of a cryptosystem is based on the robustness of the algorithm
\end_layout

\begin_layout Itemize
No algorithm, save the one-time-pad, is invulnerable
\end_layout

\begin_layout Itemize
An algorithm is broken if there is at least one attack faster than brute
 forcing
\end_layout

\begin_layout Itemize
There is no way to prove robustness of a cipher, save by trying to break
 it
\end_layout

\begin_layout Itemize
Secret algorithms are insecure.
 Security is transparency
\end_layout

\begin_layout Itemize
Key comparison:
\end_layout

\begin_deeper
\begin_layout Itemize
You can compare symmetric algorithms based on the key (e.g., CAST-128 bit
 “weaker” than AES-256)
\end_layout

\begin_layout Itemize
You cannot compare asymmetric algorithms based on key length
\end_layout

\begin_layout Itemize
More importantly, never compare asymmetric vs.
 symmetric key lengths!
\end_layout

\end_deeper
\begin_layout Section
Hash function
\end_layout

\begin_layout Subsection
Definition
\end_layout

\begin_layout Standard
A function H( ) that maps arbitrary-length input x on fixed-length output,
 h.
 Possibility of collisions because codomain “smaller” than domain.
 An hash function should be:
\end_layout

\begin_layout Itemize
Preimage attack resistant (by knowing 
\begin_inset Formula $h$
\end_inset

 it should hard to find an 
\begin_inset Formula $x$
\end_inset

 s.t.
 
\begin_inset Formula $H\left(x\right)=h$
\end_inset

)
\end_layout

\begin_layout Itemize
Second preimage attack resistant (by knowing 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $H\left(x\right)$
\end_inset

 it should be hard to find 
\begin_inset Formula $y$
\end_inset

 s.t.
 
\begin_inset Formula $H\left(x\right)=H\left(y\right)$
\end_inset

)
\end_layout

\begin_layout Itemize
Collision resistant (it should be hard to find 
\begin_inset Formula $\left\{ x,y\right\} $
\end_inset

 s.t.
 
\begin_inset Formula $H\left(x\right)=H\left(y\right)$
\end_inset

)
\end_layout

\begin_layout Standard
Notice that random collision can happen in 
\begin_inset Formula $2^{\frac{n}{2}}$
\end_inset

cases due to the birthday paradox
\end_layout

\begin_layout Section
Authentication
\end_layout

\begin_layout Subsection
Three factors of authentication
\end_layout

\begin_layout Itemize
Something that the entity knows (to know) e.g.: password, PIN, secret handshake
 
\end_layout

\begin_layout Itemize
Something that the entity has (to have) e.g.: Door key, smart card, token
\end_layout

\begin_layout Itemize
Something that the entity is (to be) e.g.: Face, voice, fingerprints
\end_layout

\begin_layout Standard
Multi-factor authentication uses two or three factors
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

To know
\begin_inset Quotes erd
\end_inset

 factor
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Low cost
\end_layout

\begin_layout Itemize
Ease of deployment
\end_layout

\begin_layout Itemize
Low technical barrier
\end_layout

\end_deeper
\begin_layout Itemize
Disadvantages: 
\end_layout

\begin_deeper
\begin_layout Itemize
Stolen/snooped (intercepted)
\end_layout

\begin_layout Itemize
Guessed 
\end_layout

\begin_layout Itemize
Cracked (enumerated)
\end_layout

\end_deeper
\begin_layout Itemize
Countermeasures (costs): 
\end_layout

\begin_deeper
\begin_layout Itemize
Change/expire frequently 
\end_layout

\begin_layout Itemize
Are long and have a rich character set
\end_layout

\begin_layout Itemize
Are not related to the user
\end_layout

\end_deeper
\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

To have
\begin_inset Quotes erd
\end_inset

 factor
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Human factor (less likely to hand out a key)
\end_layout

\begin_layout Itemize
Relatively low cost
\end_layout

\begin_layout Itemize
Good level of security
\end_layout

\end_deeper
\begin_layout Itemize
Disadvantages: 
\end_layout

\begin_deeper
\begin_layout Itemize
Hard to deploy 
\end_layout

\begin_layout Itemize
Can be lost or stolen
\end_layout

\end_deeper
\begin_layout Itemize
Countermeasures:
\end_layout

\begin_deeper
\begin_layout Itemize
Use with second factor
\end_layout

\end_deeper
\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

To be
\begin_inset Quotes erd
\end_inset

 factor
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
High level of security
\end_layout

\begin_layout Itemize
Requires no extra hardware to carry around
\end_layout

\end_deeper
\begin_layout Itemize
Disadvantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Hard to deploy
\end_layout

\begin_layout Itemize
Non-deterministic matching
\end_layout

\begin_layout Itemize
Invasive measurement
\end_layout

\begin_layout Itemize
Can be cloned
\end_layout

\begin_layout Itemize
Bio-characteristics change
\end_layout

\begin_layout Itemize
Privacy sensitivity
\end_layout

\begin_layout Itemize
Users with disabilities
\end_layout

\end_deeper
\begin_layout Itemize
Countermeasures
\end_layout

\begin_deeper
\begin_layout Itemize
Re-measure often
\end_layout

\begin_layout Itemize
Secure the process
\end_layout

\end_deeper
\begin_layout Section
Access control
\end_layout

\begin_layout Standard
Can be divided in 
\end_layout

\begin_layout Itemize
Discretionary Access Control (DAC) 
\end_layout

\begin_layout Itemize
Mandatory Access Control (MAC) 
\end_layout

\begin_layout Itemize
Role-Based Access Control (RBAC)
\end_layout

\begin_layout Standard
Difference between DAC and MAC is who assigns privileges, RBAC is sort of
 a “hybrid”
\end_layout

\begin_layout Subsection
Discretionary Access Control
\end_layout

\begin_layout Standard
Resource owner discretionarily decides its access privileges (if User1 creates
 a file, User1 can assign to User2 the privilege of reading it).
 All the OSs mostly used are DAC (e.g.
 MacOS, Linux, Windows)
\end_layout

\begin_layout Subsection
Mandatory Access Control
\end_layout

\begin_layout Standard
Basic idea: do not let owners assign privileges, which are set by a security
 administrator
\end_layout

\begin_layout Subsubsection
Bell-LaPadula model
\end_layout

\begin_layout Enumerate
Rule 1: no read up (a subject 
\begin_inset Formula $s$
\end_inset

 at a given secrecy level cannot read an object 
\begin_inset Formula $o$
\end_inset

 at a higher secrecy level)
\end_layout

\begin_layout Enumerate
Rule 2: no write down (a subject 
\begin_inset Formula $s$
\end_inset

 at a given secrecy level cannot write an object 
\begin_inset Formula $o$
\end_inset

 at a lower secrecy level)
\end_layout

\begin_layout Section
Buffer overflow
\end_layout

\begin_layout Standard
It happens when a function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

 allocates a buffer e.g.
 
\begin_inset Formula $\mathtt{\mathtt{char\quad}buf\left[8\right]}$
\end_inset

 and 
\begin_inset Formula $\mathtt{buf}$
\end_inset

is filled without size checking.
 Many typical C function does this: 
\begin_inset Formula $\mathtt{strcopy}$
\end_inset

, 
\begin_inset Formula $\mathtt{strcat}$
\end_inset

, 
\begin_inset Formula $\mathtt{fgets}$
\end_inset

, 
\begin_inset Formula $\mathtt{gets}$
\end_inset

, 
\begin_inset Formula $\mathtt{sprintf}$
\end_inset

, 
\begin_inset Formula $\mathtt{scanf}$
\end_inset


\end_layout

\begin_layout Subsection
Registers
\end_layout

\begin_layout Itemize
EBP: base pointer register
\end_layout

\begin_layout Itemize
ESP: stack pointer register (points to the top of the stack)
\end_layout

\begin_layout Itemize
EIP: istruction pointer register
\end_layout

\begin_layout Subsection
Calling convenction
\end_layout

\begin_layout Itemize
Before being executed a function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

, the CPU need to save the current EIP so it is saved on the stack.
 This operation is perfomed with the the 
\begin_inset Formula $\mathtt{call}$
\end_inset

 istruction
\end_layout

\begin_layout Itemize
After the 
\begin_inset Formula $\mathtt{jmp}$
\end_inset

 istruction the function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

 (function prologue):
\end_layout

\begin_deeper
\begin_layout Itemize
save the current stack base address onto the stack: 
\begin_inset Formula $\mathtt{\mathtt{push\quad}\%ebp}$
\end_inset

 
\end_layout

\begin_layout Itemize
the new base of the stack is the old top of the stack sub: 
\begin_inset Formula $\mathtt{\mathtt{mov\quad}\%esp,\%ebp}$
\end_inset


\end_layout

\begin_layout Itemize
allocate 0x4 bytes (32 bits integer) for foo()'s local variables: 
\begin_inset Formula $\mathtt{\mathtt{sub\quad}0x4,\%esp}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
At the end of the execution of the function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

 (function epilogue), the function:
\end_layout

\begin_deeper
\begin_layout Itemize
current base is the new top of the stack: 
\begin_inset Formula $\mathtt{\mathtt{mov\quad}\%ebp,\%esp}$
\end_inset


\end_layout

\begin_layout Itemize
restore the saved EBP to registry: 
\begin_inset Formula $\mathtt{\mathtt{pop\quad}\%ebp}$
\end_inset


\end_layout

\begin_layout Itemize
pop the saved EIP and jump there: 
\begin_inset Formula $\mathtt{ret}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Lets suppose to have this code:
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "snippets/vuln_buff_code.c"
lstparams "language={[ANSI]C}"

\end_inset

What is happened if a user insert a string longer then 8 char?
\end_layout

\begin_layout Subsection
Stack smashing
\end_layout

\begin_layout Standard
If an user insert a string 20 char long, he overvrite the saved EIP and
 can manipulate where to jump after the 
\begin_inset Formula $\mathtt{ret}$
\end_inset

 instruction
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/stack_smashing.png
	height 30theight%

\end_inset


\end_layout

\begin_layout Subsection
Defending against Buffer Overflow
\end_layout

\begin_layout Itemize
Defenses at source code level: finding and removing the vulnerabilities
 
\end_layout

\begin_layout Itemize
Defenses at compiler level: making vulnerabilities non exploitable 
\end_layout

\begin_layout Itemize
Defenses at operating system level: to thwart, or at very least make more
 difficult
\end_layout

\begin_layout Subsubsection
Defenses at Source Code Level
\end_layout

\begin_layout Itemize
Programmer errors cause buffer overflows.
 Solution is education of developers
\end_layout

\begin_layout Itemize
Using safe(r) libraries: Standard Library: 
\begin_inset Formula $\mathtt{strncpy}$
\end_inset

, 
\begin_inset Formula $\mathtt{strncat}$
\end_inset

, etc.
 (with length parameter)
\end_layout

\begin_layout Subsubsection
Compiler Level Defenses
\end_layout

\begin_layout Itemize
Randomized reordering of stack variables
\end_layout

\begin_layout Itemize
Embedding stack protection mechanisms at compile time
\end_layout

\begin_deeper
\begin_layout Itemize
Verifying, during the epilogue, that the frame has not been tampered with
\end_layout

\begin_layout Itemize
Usually a canary is inserted between local variables and control values
 (saved EIP/EBP)
\end_layout

\begin_layout Itemize
When the function returns, the canary is checked and if tampering is detected
 the program is killed
\end_layout

\end_deeper
\begin_layout Subsubsection
Canaries
\end_layout

\begin_layout Itemize
Terminator canaries: made with terminator characters (typically 
\backslash
0) which cannot be copied by string-copy functions and therefore cannot
 be overwritten
\end_layout

\begin_layout Itemize
Random canaries: random sequence of bytes, chosen when the program is run
\end_layout

\begin_layout Itemize
Random XOR canaries: same as above, but canaries XORed with part of the
 structure that we want to protect
\end_layout

\begin_layout Subsubsection
OS Level Defenses
\end_layout

\begin_layout Itemize
Non-executable stack (Return-to-libc or ROP attack still usable)
\end_layout

\begin_layout Itemize
Address layout randomization (ASLR)
\end_layout

\begin_layout Section
Format string
\end_layout

\begin_layout Subsection
Reading the stack
\end_layout

\begin_layout Standard
Consider this snippet of code:
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "snippets/vuln_format_str.c"
lstparams "language={[ANSI]C}"

\end_inset

If an user inser as 
\begin_inset Formula $\mathtt{argv\left[1\right]}$
\end_inset

 one or more placeholders (e.g.
 
\begin_inset Formula $\mathtt{\%x}$
\end_inset

), he can read some stack areas above (higher addresses) the areas allocated
 for the funcion 
\begin_inset Formula $\mathtt{printf}$
\end_inset

.
 If an user put something with a known ASCII coding (e.g.
 
\begin_inset Quotes eld
\end_inset

AAAA
\begin_inset Quotes erd
\end_inset

) following by a certain number of 
\begin_inset Formula $\mathtt{\%x}$
\end_inset

 in his format string, the user will be able to reading the string itself
 (e.g.
 he will see 
\begin_inset Quotes eld
\end_inset

41414141
\begin_inset Quotes erd
\end_inset

 somewhere)
\end_layout

\begin_layout Subsection
Writing the stack
\end_layout

\begin_layout Standard
With placeholder 
\begin_inset Formula $\mathtt{\%n}$
\end_inset

 an user can write, in the address pointed to by the argument, the number
 of chars printed so far (e.g.
 
\begin_inset Formula $\mathtt{printf("hello\%n",\&i);}$
\end_inset

 
\begin_inset Formula $\mathtt{i}$
\end_inset

 becomes equal to 5).
 So an user can control the flow execution by:
\end_layout

\begin_layout Enumerate
Putting, on the stack, the address (addr) of the memory cell (target) to
 modify
\end_layout

\begin_layout Enumerate
Use %x to go find it on the stack
\end_layout

\begin_layout Enumerate
Use %n to write an arbitrary number in the cell pointed to by addr, which
 is target
\end_layout

\begin_layout Standard
so the structure of the format string should be the following:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/format_string.png
	width 75text%

\end_inset


\end_layout

\begin_layout Section
Web app security
\end_layout

\begin_layout Standard
The golden rule of web application security is that the client is never
 trustworthy, so we need to filter and check carefully anything that is
 sent to us
\end_layout

\begin_layout Subsection
XSS (cross-site scripting)
\end_layout

\begin_layout Standard
Cross site scripting (XSS) is a vulnerability by means of which client-side
 code can be injected in a page.
 For example if in a blog site an user insert a comment like this:
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "snippets/xss_example.js"
lstparams "language=HTML"

\end_inset

without adeguate filtering policy, popup would appear on next visitors’
 screen
\end_layout

\begin_layout Subsubsection
Stored XSS (AKA Persistent)
\end_layout

\begin_layout Standard
The attacker input is stored on the target server, such as in a database,
 in a message forum, visitor log, comment field, etc
\end_layout

\begin_layout Subsubsection
Reflected XSS (AKA Non-Persistent)
\end_layout

\begin_layout Standard
User input is immediately returned by a web application in an error message,
 search result, or any other response that includes some or all of the input
 provided by the user as part of the request without permanently storing
 the user provided data
\end_layout

\begin_layout Subsubsection
DOM Based XSS
\end_layout

\begin_layout Standard
The user provided data never even leave the browser so the attack payload
 is executed as a result of modifying the DOM “environment” in the victim’s
 browser
\end_layout

\begin_layout Subsubsection
Escaping policy
\end_layout

\begin_layout Standard
Blacklisting or whitelisting are not the right policies for handle this
 vulnerability, instead if we adopt a filtering policy.
 for instance we can swap 
\begin_inset Formula $\mathtt{>}$
\end_inset

 with its HTML safe equivalent 
\begin_inset Formula $\mathtt{\&gt;}$
\end_inset

 and 
\begin_inset Formula $\mathtt{<}$
\end_inset

 with 
\begin_inset Formula $\mathtt{\&lt;}$
\end_inset


\end_layout

\begin_layout Subsection
SQL injection
\end_layout

\begin_layout Standard
Consider this function:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "snippets/vuln_sql_inj.java"
lstparams "language={[AspectJ]Java}"

\end_inset

it is clearly vulnerable to SQL injection because doesn't filter the user
 input before exectue the query.
 In fact if an user insert as username something like 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathtt{someUser';--}$
\end_inset


\begin_inset Quotes erd
\end_inset

 the query wold be:
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "snippets/sql_inj_query.sql"
lstparams "language=SQL"

\end_inset

and all is after the two dashes is commented out, so an attacker can log
 in as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathtt{someUser}$
\end_inset


\begin_inset Quotes erd
\end_inset

 without knowing his password.
 The solution of this vulnerability is to filter the user input before execute
 the SQL query
\end_layout

\begin_layout Subsubsection
Blind SQL injection
\end_layout

\begin_layout Itemize
Some SQL queries, such as the login query we saw, do not display returned
 values
\end_layout

\begin_layout Itemize
Rather, they do, or do not do, stuff based on the return value
\end_layout

\begin_layout Itemize
We cannot use them to directly display data, but we can play with their
 behavior to infer data
\end_layout

\begin_layout Subsection
CSRS (cross-site request forgery)
\end_layout

\begin_layout Standard
Forces an user to execute unwanted actions (state-changing action) on a
 web application in which he is currently authenticated (e.g., with cookies).
 To mitigate this attack is to use a random session token:
\end_layout

\begin_layout Itemize
Associated to user’s session (unique)
\end_layout

\begin_layout Itemize
Regenerated at each request (e.g., for form involving sensitive operations)
\end_layout

\begin_layout Itemize
Sent to the server and then compared against the stored token
\end_layout

\begin_layout Itemize
Server-side operation allowed only if it matches
\end_layout

\begin_layout Subsection
Other vulnerabilities
\end_layout

\begin_layout Subsubsection
URL parameter tampering
\end_layout

\begin_layout Standard
When in the URL there is something like 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathtt{someId=1297}$
\end_inset


\begin_inset Quotes erd
\end_inset

 by changing this id it is possible to access to data that the user 1297
 is not allow to see
\end_layout

\begin_layout Subsubsection
Path traversal
\end_layout

\begin_layout Standard
If the name of a specifc file given by the user is not adequately filtered,
 an attacker can insert a series of 
\begin_inset Formula $\mathtt{../}$
\end_inset

 (this attack is also called 
\begin_inset Quotes eld
\end_inset

dot dot slash
\begin_inset Quotes erd
\end_inset

) in order to reach the root and access whatever he want (e.g.
 
\begin_inset Formula $\mathtt{../../../../../../etc/passwd}$
\end_inset

)
\end_layout

\begin_layout Section
Network protocol attack
\end_layout

\begin_layout Subsection
Taxonomy
\end_layout

\begin_layout Itemize
Denial of Service (against availability): service unavailable to legitimate
 users 
\end_layout

\begin_layout Itemize
Sniffing (against confidentiality): abusive reading of network packets 
\end_layout

\begin_layout Itemize
Spoofing (against integrity and authenticity): forging network packets
\end_layout

\begin_layout Subsection
DDoS (distributed denial-of-service)
\end_layout

\begin_layout Standard
A distributed denial-of-service (DDoS) is a large-scale DoS attack where
 the perpetrator uses more than one unique IP address, often thousands of
 them.
 Since the incoming traffic flooding the victim originates from many different
 sources, it is impossible to stop the attack simply by using ingress filtering.
 It also makes it very difficult to distinguish legitimate user traffic
 from attack traffic when spread across so many points of origin.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/DDos_Attack.svg
	width 75text%
	height 60theight%

\end_inset


\end_layout

\begin_layout Subsubsection
SYN flood attack
\end_layout

\begin_layout Standard
Attacker generates a high volume of SYN requests with spoofed source address.
 Many half-open TCP/IP connections fill the queue.
 SYN requests from legitimate clients dropped
\end_layout

\begin_layout Subsubsection
Smurf
\end_layout

\begin_layout Standard
The Smurf attack is an attack in which large numbers of Internet Control
 Message Protocol (ICMP) packets (ping) with the intended victim's spoofed
 source IP are broadcast to a computer network using an IP broadcast address.
 Most devices on a network will, by default, respond to this by sending
 a reply to the source IP address.
 If the number of machines on the network that receive and respond to these
 packets is very large, the victim's computer will be flooded with traffic
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/smurf_attack.png
	width 85text%

\end_inset


\end_layout

\begin_layout Subsection
Network sniffing
\end_layout

\begin_layout Standard
Normally, a network interface card (NIC) intercepts and passes to the OS
 only the packets directed to that host's IP.
 In promiscuous mode the NIC passess to the OS any packet read.
 Mitigation for sniffing can be to use switched networks instead hub-based
 networks (hubs broadcast traffic to every host, Switches selectively relay
 traffic to the wire corresponding to the correct NIC)
\end_layout

\begin_layout Subsection
ARP spoofing
\end_layout

\begin_layout Standard
The ARP basically maps 32-bits IPv4 addresses to 48-bits hardware or MAC
 addresses.
 The main vulnerability about ARP are:
\end_layout

\begin_layout Itemize
First come, first trusted so an attacker can forge replies easily: lack
 of authentication
\end_layout

\begin_layout Itemize
Each host caches the replies
\end_layout

\begin_layout Itemize
Switches use CAM tables to know (i.e., cache) which MAC addresses are on which
 ports.
 It is possible using some tools to fills the CAM table in seconds by generating
 a lot of spoofed packets.
 When CAM table is full switches cannot cache ARP replies and must forward
 everything to every port (like a hub does)
\end_layout

\begin_layout Subsection
IP spoofing
\end_layout

\begin_layout Standard
The IP source address is not authenticated.
 Changing it in UDP or ICMP packets is easy.
 However, the attacker will not see the answers, because they will be sent
 to the spoofed host (blind spoofing).
 But if the attacker is on the same network, he can sniff the rest, or use
 ARP spoofing
\end_layout

\begin_layout Subsection
TCP session hijacking
\end_layout

\begin_layout Itemize
TCP uses sequence numbers for reordering and acknowledging packets
\end_layout

\begin_layout Itemize
A semi-random initial SEQuence number (ISN) is chosen
\end_layout

\begin_layout Itemize
If a blind spoofer can predict the ISN, he can blindly complete the 3-way
 handshake without seeing the answers
\end_layout

\begin_layout Itemize
Else if the attacker (C) can sniff the packets of an already active TCP
 session:
\end_layout

\begin_deeper
\begin_layout Itemize
C follows the conversation of A and B recording the sequence numbers
\end_layout

\begin_layout Itemize
C somehow disrupts B's connection (e.g.
 SYN Flood): B sees only a “random” disruption of service
\end_layout

\begin_layout Itemize
C takes over the dialogue with A by spoofing B address and starting with
 a correct ISN.
\end_layout

\end_deeper
\begin_layout Subsection
MITM (man in the middle)
\end_layout

\begin_layout Standard
An attack where an attacker can impersonate the server with respect to the
 client and vice-versa:
\end_layout

\begin_layout Itemize
physical or logical MITM
\end_layout

\begin_layout Itemize
full or half-duplex (blind)
\end_layout

\begin_layout Subsection
DNS poisoning
\end_layout

\begin_layout Standard
DNS is on UDP transport, sothe messages are not authenticated.
 When a non-authoritative DNS server receives a request to resolve a domain
 name:
\end_layout

\begin_layout Itemize
if it cached the answer, it answers
\end_layout

\begin_layout Itemize
If no answer in cache: 
\end_layout

\begin_deeper
\begin_layout Itemize
Recursion: resolves the name on behalf of the client
\end_layout

\begin_layout Itemize
Iterative: gives the authoritative DNS address
\end_layout

\end_deeper
\begin_layout Standard
If an attacker makes a recursive query to the victim DNS server:
\end_layout

\begin_layout Itemize
The victim DNS serverwill contact the authoritative server
\end_layout

\begin_layout Itemize
The attacker spoofs the answer impersonating the authoritative DNS server
 and the server will trust it
\end_layout

\begin_layout Subsection
DHCP poisoning
\end_layout

\begin_layout Standard
DHCP is not authenticated.
 The attacker can intercept requests, be the first to answer, and client
 will believe that answer.
 With a single (spoofed) DHCP response, the attacker can set IP address,
 DNS addresses, default gateway of the victim client
\end_layout

\begin_layout Subsection
ICMP redirect
\end_layout

\begin_layout Standard
Tells an host that a better route exists for a given destination, and gives
 the gateway for that route.
 The attacker can forge an ICMP redirect packet to elect his computer as
 the gateway.
 The attacker needs to intercept a packet in the “original” connection in
 order to forge the reply
\end_layout

\begin_layout Section
Firewalls
\end_layout

\begin_layout Standard
A firewall is a network access control system that verifies all the packets
 flowing through it.
 Its main functions are usually: 
\end_layout

\begin_layout Itemize
IP packet filtering
\end_layout

\begin_layout Itemize
Network address translation (NAT)
\end_layout

\begin_layout Standard
Firewalls can be devided depending on their packet inspection capability:
\end_layout

\begin_layout Itemize
Network layer firewalls
\end_layout

\begin_deeper
\begin_layout Itemize
Packet filters (network)
\end_layout

\begin_layout Itemize
Stateful packet filters (network-transport)
\end_layout

\end_deeper
\begin_layout Itemize
Application layer firewalls
\end_layout

\begin_deeper
\begin_layout Itemize
Circuit level firewalls (transport-application)
\end_layout

\begin_layout Itemize
Application proxies (application)
\end_layout

\end_deeper
\begin_layout Subsection
Packet filters
\end_layout

\begin_layout Standard
Regardless of the specific syntax, every network packet filter allows to
 express the following concept: if (packet matches certain condition) do
 this e.g.: 
\end_layout

\begin_layout Itemize
Block 
\end_layout

\begin_layout Itemize
Allow 
\end_layout

\begin_layout Itemize
Log 
\end_layout

\begin_layout Itemize
Other actions
\end_layout

\begin_layout Standard
Packet filters are stateless: cannot track TCP connections
\end_layout

\begin_layout Subsection
Stateful (or dynamic) packet filters
\end_layout

\begin_layout Standard
Include network packet filters, plus:
\end_layout

\begin_layout Itemize
Keep track of the TCP state machine 
\end_layout

\begin_layout Itemize
We can track connections without adding a response rule
\end_layout

\begin_layout Standard
Session-handling is fundamental for NAT
\end_layout

\begin_layout Subsection
Circuit firewalls (legacy) 
\end_layout

\begin_layout Standard
Client connects to a specific TCP port on the firewall, which then connects
 to the address and port of the desired server (not transparent).
 Essentially, a TCP-level proxy
\end_layout

\begin_layout Subsection
Application proxies 
\end_layout

\begin_layout Standard
Same as circuit firewalls, but at application layer.
 Inspect, validate, manipulate protocol application data (e.g., rewrite HTTP
 frames).
 Almost never transparent to clients
\end_layout

\begin_layout Section
Secure network architecture
\end_layout

\begin_layout Subsection
Dual- or Multi-zone architectures
\end_layout

\begin_layout Standard
In most cases, the perimeter defense works on the assumption that what is
 “good” is inside, and what's outside should be kept outside if possible.
 There are two counterexamples: 
\end_layout

\begin_layout Itemize
Access to resources from remote (i.e., to a web server, to FTP, mail transfer)
\end_layout

\begin_layout Itemize
Access from remote users to the corporate network
\end_layout

\begin_layout Standard
Problem: if we mix externally accessible servers with internal clients,
 we lower the security of the internal network.
 Solution: we allow external access to the accessible servers, but not to
 the internal network.
 In practice, we create a semi-public zone called DMZ (demilitarized zone).
 The DMZ will host public servers (web, FTP, public DNS server, intake SMTP).
 On the DMZ no critical or irreplaceable data
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/DMZ+private_zone.png
	width 85text%

\end_inset


\end_layout

\begin_layout Subsection
VPN (virtual private network)
\end_layout

\begin_layout Standard
If a user need to:
\end_layout

\begin_layout Itemize
Work “as if” they were in the office, accessing resources on the private
 zone
\end_layout

\begin_layout Itemize
Connect remote sites without using dedicated lines
\end_layout

\begin_layout Itemize
Ensure CIA (confidentiality, integrity, availability) to data transmitted
 over a public network (i.e., the Internet)
\end_layout

\begin_layout Standard
The solution is to use a VPN, an encrypted overlay connection over a (public)
 network
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/vpn.png
	width 85text%

\end_inset


\end_layout

\begin_layout Itemize
Full tunnelling:
\end_layout

\begin_deeper
\begin_layout Itemize
Every packet goes through the tunnel
\end_layout

\begin_layout Itemize
Traffic multiplication, could be inefficient
\end_layout

\begin_layout Itemize
Single point of control and application of all security policies as if the
 client were in the corporate network
\end_layout

\end_deeper
\begin_layout Itemize
Split tunnelling
\end_layout

\begin_deeper
\begin_layout Itemize
Traffic to the corporate network: in VPN
\end_layout

\begin_layout Itemize
traffic to the Internet: directly to ISP
\end_layout

\begin_layout Itemize
More efficient, less control
\end_layout

\begin_layout Itemize
Just similar to the case of the PC connected via 3G modem to the Internet
\end_layout

\end_deeper
\begin_layout Section
Network Security
\end_layout

\begin_layout Itemize
Problems of remoteness 
\end_layout

\begin_deeper
\begin_layout Itemize
Trust factor between parties
\end_layout

\begin_layout Itemize
Use of sensitive data
\end_layout

\begin_layout Itemize
Atomicity of transaction 
\end_layout

\end_deeper
\begin_layout Itemize
Internet protocol problems
\end_layout

\begin_deeper
\begin_layout Itemize
Authentication
\end_layout

\begin_layout Itemize
Confidentiality 
\end_layout

\begin_layout Itemize
Transparence and critical mass problem
\end_layout

\end_deeper
\begin_layout Standard
Two possible solutions:
\end_layout

\begin_layout Itemize
HTTP over SSL (Secure Socket Layer), or HTTPS
\end_layout

\begin_deeper
\begin_layout Itemize
Communication confidentiality and integrity 
\end_layout

\begin_layout Itemize
Mutual authentication 
\end_layout

\begin_layout Itemize
No guarantees on data usage 
\end_layout

\begin_layout Itemize
No strict authentication of client (in practice)
\end_layout

\end_deeper
\begin_layout Itemize
SET (Secure Electronic Transaction) 
\end_layout

\begin_deeper
\begin_layout Itemize
Guarantees on data usage and transaction security enforcement 
\end_layout

\begin_layout Itemize
Missing critical mass support
\end_layout

\end_deeper
\begin_layout Subsection
SSL
\end_layout

\begin_layout Standard
SSL enforces: 
\end_layout

\begin_layout Itemize
Confidentiality and integrity of the communications
\end_layout

\begin_layout Itemize
Server authentication 
\end_layout

\begin_layout Itemize
Client authentication (optionally) 
\end_layout

\begin_layout Standard
It uses both symmetric and asymmetric cryptography for performance reasons
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/HTTPS.png
	width 70text%

\end_inset


\end_layout

\begin_layout Itemize
PROs
\end_layout

\begin_deeper
\begin_layout Itemize
Protects transmissions
\end_layout

\begin_layout Itemize
Ensures authentication
\end_layout

\begin_layout Itemize
design to be resistant to MITM
\end_layout

\end_deeper
\begin_layout Itemize
CONs
\end_layout

\begin_deeper
\begin_layout Itemize
No protection before or after transmission
\end_layout

\begin_layout Itemize
Relies on PKI
\end_layout

\begin_layout Itemize
Not foolproof
\end_layout

\end_deeper
\begin_layout Section
Malware
\end_layout

\begin_layout Standard
Malware is code that is intentionally written to violate a security policy.
 Three main categories of malware:
\end_layout

\begin_layout Itemize
Viruses: self-propagate by infecting other files, usually executables (but
 also documents with macros, boot loader code).
 They are not programs (i.e., not executables)
\end_layout

\begin_layout Itemize
Worms: programs that self-propagate, even remotely, often by exploiting
 host vulnerabilities, or by social engineering (e.g., mail worms)
\end_layout

\begin_layout Itemize
Trojan horses: apparently benign program that hide a malicious functionality
 and allow remote control
\end_layout

\begin_layout Subsection
Botnets
\end_layout

\begin_layout Standard
A botnet is a network that consists of several malicious bots that are controlle
d by a commander, commonly known as botmaster (botherder).
 The main threats caused by the botnets are:
\end_layout

\begin_layout Itemize
For the infected host: 
\end_layout

\begin_deeper
\begin_layout Itemize
information harvesting
\end_layout

\begin_layout Itemize
Identity data Financial data 
\end_layout

\begin_layout Itemize
Private data E-mail address books 
\end_layout

\begin_layout Itemize
Any other type of data that may be present on the host of the victim
\end_layout

\end_deeper
\begin_layout Itemize
For the rest of the Internet
\end_layout

\begin_deeper
\begin_layout Itemize
Spamming 
\end_layout

\begin_layout Itemize
DDoS 
\end_layout

\begin_layout Itemize
Propagation (network or email worm) 
\end_layout

\begin_layout Itemize
Support infrastructure for illegal internet activity (the botnet itself,
 phishing sites, drive-by-download sites)
\end_layout

\end_deeper
\begin_layout Subsection
Antivirus and anti-malware
\end_layout

\begin_layout Itemize
Basic strategy is signature-based detection: database of byte-level or instructi
on-level signatures that match malware
\end_layout

\begin_layout Itemize
Implemented through 
\end_layout

\begin_deeper
\begin_layout Itemize
Heuristics algorithm (check for signs of infection) e.g.:
\end_layout

\begin_deeper
\begin_layout Itemize
Code execution starts in last section 
\end_layout

\begin_layout Itemize
Incorrect header size in PE header 
\end_layout

\begin_layout Itemize
Suspicious code section name 
\end_layout

\begin_layout Itemize
Patched import address table
\end_layout

\end_deeper
\begin_layout Itemize
Behavioral Detection:
\end_layout

\begin_deeper
\begin_layout Itemize
Detect signs (behavior) of known malware 
\end_layout

\begin_layout Itemize
Dtect “common behaviors” of malware
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
Virus and Worm Stealth Techniques
\end_layout

\begin_layout Itemize
Entry Point Obfuscation
\end_layout

\begin_deeper
\begin_layout Itemize
Multicavity viruses 
\end_layout

\begin_layout Itemize
Virus hijacks control later (after program is launched) 
\end_layout

\begin_deeper
\begin_layout Itemize
Overwrite import table addresses (e.g., libraries) 
\end_layout

\begin_layout Itemize
Overwrite function call instructions
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Polymorphism
\end_layout

\begin_deeper
\begin_layout Itemize
Change layout (shape) with each infection 
\end_layout

\begin_layout Itemize
Payload is encrypted (~ packing) 
\end_layout

\begin_deeper
\begin_layout Itemize
Using different key for each infection 
\end_layout

\begin_layout Itemize
Makes static string analysis practically impossible 
\end_layout

\begin_layout Itemize
Of course, AV could detect encryption routine
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Metamorphism
\end_layout

\begin_deeper
\begin_layout Itemize
create different “versions” of code that look different but have the same
 semantics (i.e., do the same)
\end_layout

\end_deeper
\begin_layout Itemize
Dormant period 
\end_layout

\begin_deeper
\begin_layout Itemize
During which no malicious behavior is exhibited 
\end_layout

\end_deeper
\begin_layout Itemize
Event-triggered payload 
\end_layout

\begin_layout Itemize
Encryption / Packing 
\end_layout

\begin_deeper
\begin_layout Itemize
Similar to polymorphism but more advanced techniques are available in more
 complex malware 
\end_layout

\end_deeper
\begin_layout Itemize
Rootkit techniques
\end_layout

\begin_deeper
\begin_layout Itemize
Anti-virtualization techniques
\end_layout

\end_deeper
\end_body
\end_document
