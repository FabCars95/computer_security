#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
HRule}{
\backslash
rule{
\backslash
linewidth}{0.5mm}}
\end_layout

\begin_layout Plain Layout


\backslash
center
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
LARGE Politecnico di Milano}
\backslash

\backslash
[1.5cm] 
\backslash
textsc{
\backslash
Large Computer Security}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout


\backslash
textsc{
\backslash
Large Short Summary}
\backslash

\backslash
[0.5cm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\backslash
begin{flushleft} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
emph{Authors:}
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout


\backslash
textsc{FabC07} 
\backslash
newline 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushleft} 
\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

~
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth} 
\backslash
begin{flushright} 
\backslash
large 
\end_layout

\begin_layout Plain Layout


\backslash
end{flushright} 
\backslash
end{minipage}
\backslash

\backslash
[3cm]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename logo/logopm.svg
	width 5cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{gobble}
\end_layout

\begin_layout Plain Layout

{
\backslash
large 
\backslash
today}
\backslash

\backslash
[3cm]
\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
tableofcontents{}
\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Fundamentals of cryptography
\end_layout

\begin_layout Subsection
One-time-pad
\end_layout

\begin_layout Itemize
XOR of a message m and a random key k of the same size of m: 
\begin_inset Formula $len(k)=len(m)$
\end_inset


\end_layout

\begin_layout Itemize
The key is pre-shared and consumed while writing.
 It can never be re-used again
\end_layout

\begin_layout Itemize
Very inconvenient and used only in special cases
\end_layout

\begin_layout Subsection
Symmetric encryption
\end_layout

\begin_layout Itemize
Use key K to encrypt plaintext in ciphertext.
 Use same key K to decrypt ciphertext in plaintext
\end_layout

\begin_layout Itemize
Two important concepts:
\end_layout

\begin_deeper
\begin_layout Itemize
Substitution: replacing each byte with another (e.g.
 Caesar cipher)
\end_layout

\begin_layout Itemize
Transposition: swapping the values of given bits (e.g.
 matrix)
\end_layout

\end_deeper
\begin_layout Subsection
Asymmetric encryption
\end_layout

\begin_layout Itemize
a cipher that uses two keys:
\end_layout

\begin_deeper
\begin_layout Itemize
What is encrypted with key1 can be decrypted only with key2 (and not with
 key1 itself), and viceversa
\end_layout

\begin_layout Itemize
The keys cannot be retrieved from each other
\end_layout

\end_deeper
\begin_layout Itemize
Diffie-Hellman Exchange algorithm:
\end_layout

\begin_deeper
\begin_layout Itemize
based on factorization problem
\end_layout

\begin_layout Itemize
Pick 
\begin_inset Formula $p$
\end_inset

 prime, 
\begin_inset Formula $a$
\end_inset

 primitive root of 
\begin_inset Formula $p$
\end_inset

, public (both Alice and Bob know)
\end_layout

\begin_layout Itemize
Pick a number 
\begin_inset Formula $X$
\end_inset

 in 
\begin_inset Formula $\left[1,\ldots,\right]\left(n-1\right)$
\end_inset

 (this is secret and is the private key of Alice 
\begin_inset Formula $X_{A}$
\end_inset

and Bob 
\begin_inset Formula $X_{B}$
\end_inset

)
\end_layout

\begin_layout Itemize
Obtain the public key as 
\begin_inset Formula $Y_{A}=\left(a^{X_{A}}\right)mod\left(p\right)$
\end_inset

 (for Alice) and 
\begin_inset Formula $Y_{B}=\left(a^{X_{B}}\right)mod\left(p\right)$
\end_inset

(for Bob) and exchange them
\end_layout

\begin_layout Itemize
Compute the common secret as 
\begin_inset Formula $K_{A}=\left(Y_{B}^{X_{A}}\right)mod\left(p\right)=K_{B}=\left(Y_{A}^{X_{B}}\right)mod\left(p\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
RSA algorithm:
\end_layout

\begin_deeper
\begin_layout Itemize
based on factorization problem
\end_layout

\begin_layout Itemize
Pick 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 two large primes
\end_layout

\begin_layout Itemize
Computing n = p * q is easy, but given n it is painfully slow to get p and
 q 
\end_layout

\begin_layout Itemize
Different problem than mod-log (D-H)
\end_layout

\begin_layout Itemize
At least 1024-bit key (typical choice are 2048-bit or 4096-bit)
\end_layout

\end_deeper
\begin_layout Subsection
Important notes
\end_layout

\begin_layout Itemize
Security of a cryptosystem is based on the robustness of the algorithm
\end_layout

\begin_layout Itemize
No algorithm, save the one-time-pad, is invulnerable
\end_layout

\begin_layout Itemize
An algorithm is broken if there is at least one attack faster than brute
 forcing
\end_layout

\begin_layout Itemize
There is no way to prove robustness of a cipher, save by trying to break
 it
\end_layout

\begin_layout Itemize
Secret algorithms are insecure.
 Security is transparency
\end_layout

\begin_layout Itemize
Key comparison:
\end_layout

\begin_deeper
\begin_layout Itemize
You can compare symmetric algorithms based on the key (e.g., CAST-128 bit
 “weaker” than AES-256)
\end_layout

\begin_layout Itemize
You cannot compare asymmetric algorithms based on key length
\end_layout

\begin_layout Itemize
More importantly, never compare asymmetric vs.
 symmetric key lengths!
\end_layout

\end_deeper
\begin_layout Section
Hash function
\end_layout

\begin_layout Subsection
Definition
\end_layout

\begin_layout Standard
A function H( ) that maps arbitrary-length input x on fixed-length output,
 h.
 Possibility of collisions because codomain “smaller” than domain.
 An hash function should be:
\end_layout

\begin_layout Itemize
Preimage attack resistant (by knowing 
\begin_inset Formula $h$
\end_inset

 it should hard to find an 
\begin_inset Formula $x$
\end_inset

 s.t.
 
\begin_inset Formula $H\left(x\right)=h$
\end_inset

)
\end_layout

\begin_layout Itemize
Second preimage attack resistant (by knowing 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $H\left(x\right)$
\end_inset

 it should be hard to find 
\begin_inset Formula $y$
\end_inset

 s.t.
 
\begin_inset Formula $H\left(x\right)=H\left(y\right)$
\end_inset

)
\end_layout

\begin_layout Itemize
Collision resistant (it should be hard to find 
\begin_inset Formula $\left\{ x,y\right\} $
\end_inset

 s.t.
 
\begin_inset Formula $H\left(x\right)=H\left(y\right)$
\end_inset

)
\end_layout

\begin_layout Standard
Notice that random collision can happen in 
\begin_inset Formula $2^{\frac{n}{2}}$
\end_inset

cases due to the birthday paradox
\end_layout

\begin_layout Section
Authentication
\end_layout

\begin_layout Subsection
Three factors of authentication
\end_layout

\begin_layout Itemize
Something that the entity knows (to know) e.g.: password, PIN, secret handshake
 
\end_layout

\begin_layout Itemize
Something that the entity has (to have) e.g.: Door key, smart card, token
\end_layout

\begin_layout Itemize
Something that the entity is (to be) e.g.: Face, voice, fingerprints
\end_layout

\begin_layout Standard
Multi-factor authentication uses two or three factors
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

To know
\begin_inset Quotes erd
\end_inset

 factor
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Low cost
\end_layout

\begin_layout Itemize
Ease of deployment
\end_layout

\begin_layout Itemize
Low technical barrier
\end_layout

\end_deeper
\begin_layout Itemize
Disadvantages: 
\end_layout

\begin_deeper
\begin_layout Itemize
Stolen/snooped (intercepted)
\end_layout

\begin_layout Itemize
Guessed 
\end_layout

\begin_layout Itemize
Cracked (enumerated)
\end_layout

\end_deeper
\begin_layout Itemize
Countermeasures (costs): 
\end_layout

\begin_deeper
\begin_layout Itemize
Change/expire frequently 
\end_layout

\begin_layout Itemize
Are long and have a rich character set
\end_layout

\begin_layout Itemize
Are not related to the user
\end_layout

\end_deeper
\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

To have
\begin_inset Quotes erd
\end_inset

 factor
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Human factor (less likely to hand out a key)
\end_layout

\begin_layout Itemize
Relatively low cost
\end_layout

\begin_layout Itemize
Good level of security
\end_layout

\end_deeper
\begin_layout Itemize
Disadvantages: 
\end_layout

\begin_deeper
\begin_layout Itemize
Hard to deploy 
\end_layout

\begin_layout Itemize
Can be lost or stolen
\end_layout

\end_deeper
\begin_layout Itemize
Countermeasures:
\end_layout

\begin_deeper
\begin_layout Itemize
Use with second factor
\end_layout

\end_deeper
\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

To be
\begin_inset Quotes erd
\end_inset

 factor
\end_layout

\begin_layout Itemize
Advantages:
\end_layout

\begin_deeper
\begin_layout Itemize
High level of security
\end_layout

\begin_layout Itemize
Requires no extra hardware to carry around
\end_layout

\end_deeper
\begin_layout Itemize
Disadvantages:
\end_layout

\begin_deeper
\begin_layout Itemize
Hard to deploy
\end_layout

\begin_layout Itemize
Non-deterministic matching
\end_layout

\begin_layout Itemize
Invasive measurement
\end_layout

\begin_layout Itemize
Can be cloned
\end_layout

\begin_layout Itemize
Bio-characteristics change
\end_layout

\begin_layout Itemize
Privacy sensitivity
\end_layout

\begin_layout Itemize
Users with disabilities
\end_layout

\end_deeper
\begin_layout Itemize
Countermeasures
\end_layout

\begin_deeper
\begin_layout Itemize
Re-measure often
\end_layout

\begin_layout Itemize
Secure the process
\end_layout

\end_deeper
\begin_layout Section
Access control
\end_layout

\begin_layout Standard
Can be divided in 
\end_layout

\begin_layout Itemize
Discretionary Access Control (DAC) 
\end_layout

\begin_layout Itemize
Mandatory Access Control (MAC) 
\end_layout

\begin_layout Itemize
Role-Based Access Control (RBAC)
\end_layout

\begin_layout Standard
Difference between DAC and MAC is who assigns privileges, RBAC is sort of
 a “hybrid”
\end_layout

\begin_layout Subsection
Discretionary Access Control
\end_layout

\begin_layout Standard
Resource owner discretionarily decides its access privileges (if User1 creates
 a file, User1 can assign to User2 the privilege of reading it).
 All the OSs mostly used are DAC (e.g.
 MacOS, Linux, Windows)
\end_layout

\begin_layout Subsection
Mandatory Access Control
\end_layout

\begin_layout Standard
Basic idea: do not let owners assign privileges, which are set by a security
 administrator
\end_layout

\begin_layout Subsubsection
Bell-LaPadula model
\end_layout

\begin_layout Enumerate
Rule 1: no read up (a subject 
\begin_inset Formula $s$
\end_inset

 at a given secrecy level cannot read an object 
\begin_inset Formula $o$
\end_inset

 at a higher secrecy level)
\end_layout

\begin_layout Enumerate
Rule 2: no write down (a subject 
\begin_inset Formula $s$
\end_inset

 at a given secrecy level cannot write an object 
\begin_inset Formula $o$
\end_inset

 at a lower secrecy level)
\end_layout

\begin_layout Section
Buffer overflow
\end_layout

\begin_layout Standard
It happens when a function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

 allocates a buffer e.g.
 
\begin_inset Formula $\mathtt{\mathtt{char\quad}buf\left[8\right]}$
\end_inset

 and 
\begin_inset Formula $\mathtt{buf}$
\end_inset

is filled without size checking.
 Many typical C function does this: 
\begin_inset Formula $\mathtt{strcopy}$
\end_inset

, 
\begin_inset Formula $\mathtt{strcat}$
\end_inset

, 
\begin_inset Formula $\mathtt{fgets}$
\end_inset

, 
\begin_inset Formula $\mathtt{gets}$
\end_inset

, 
\begin_inset Formula $\mathtt{sprintf}$
\end_inset

, 
\begin_inset Formula $\mathtt{scanf}$
\end_inset


\end_layout

\begin_layout Subsection
Registers
\end_layout

\begin_layout Itemize
EBP: base pointer register
\end_layout

\begin_layout Itemize
ESP: stack pointer register (points to the top of the stack)
\end_layout

\begin_layout Itemize
EIP: istruction pointer register
\end_layout

\begin_layout Subsection
Calling convenction
\end_layout

\begin_layout Itemize
Before being executed a function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

, the CPU need to save the current EIP so it is saved on the stack.
 This operation is perfomed with the the 
\begin_inset Formula $\mathtt{call}$
\end_inset

 istruction
\end_layout

\begin_layout Itemize
After the 
\begin_inset Formula $\mathtt{jmp}$
\end_inset

 istruction the function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

 (function prologue):
\end_layout

\begin_deeper
\begin_layout Itemize
save the current stack base address onto the stack: 
\begin_inset Formula $\mathtt{\mathtt{push\quad}\%ebp}$
\end_inset

 
\end_layout

\begin_layout Itemize
the new base of the stack is the old top of the stack sub: 
\begin_inset Formula $\mathtt{\mathtt{mov\quad}\%esp,\%ebp}$
\end_inset


\end_layout

\begin_layout Itemize
allocate 0x4 bytes (32 bits integer) for foo()'s local variables: 
\begin_inset Formula $\mathtt{\mathtt{sub\quad}0x4,\%esp}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
At the end of the execution of the function 
\begin_inset Formula $\mathtt{\mathtt{foo\left(\right)}}$
\end_inset

 (function epilogue), the function:
\end_layout

\begin_deeper
\begin_layout Itemize
current base is the new top of the stack: 
\begin_inset Formula $\mathtt{\mathtt{mov\quad}\%ebp,\%esp}$
\end_inset


\end_layout

\begin_layout Itemize
restore the saved EBP to registry: 
\begin_inset Formula $\mathtt{\mathtt{pop\quad}\%ebp}$
\end_inset


\end_layout

\begin_layout Itemize
pop the saved EIP and jump there: 
\begin_inset Formula $\mathtt{ret}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Lets suppose to have this code:
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "snippets/vuln_buff_code.c"
lstparams "language={[ANSI]C}"

\end_inset

What is happened if a user insert a string longer then 8 char?
\end_layout

\begin_layout Subsection
Stack smashing
\end_layout

\begin_layout Standard
If an user insert a string 20 char long, he overvrite the saved EIP and
 can manipulate where to jump after the 
\begin_inset Formula $\mathtt{ret}$
\end_inset

 instruction
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/stack_smashing.png
	height 30theight%

\end_inset


\end_layout

\begin_layout Subsection
Defending against Buffer Overflow
\end_layout

\begin_layout Itemize
Defenses at source code level: finding and removing the vulnerabilities
 
\end_layout

\begin_layout Itemize
Defenses at compiler level: making vulnerabilities non exploitable 
\end_layout

\begin_layout Itemize
Defenses at operating system level: to thwart, or at very least make more
 difficult
\end_layout

\begin_layout Subsubsection
Defenses at Source Code Level
\end_layout

\begin_layout Itemize
Programmer errors cause buffer overflows.
 Solution is education of developers
\end_layout

\begin_layout Itemize
Using safe(r) libraries: Standard Library: 
\begin_inset Formula $\mathtt{strncpy}$
\end_inset

, 
\begin_inset Formula $\mathtt{strncat}$
\end_inset

, etc.
 (with length parameter)
\end_layout

\begin_layout Subsubsection
Compiler Level Defenses
\end_layout

\begin_layout Itemize
Randomized reordering of stack variables
\end_layout

\begin_layout Itemize
Embedding stack protection mechanisms at compile time
\end_layout

\begin_deeper
\begin_layout Itemize
Verifying, during the epilogue, that the frame has not been tampered with
\end_layout

\begin_layout Itemize
Usually a canary is inserted between local variables and control values
 (saved EIP/EBP)
\end_layout

\begin_layout Itemize
When the function returns, the canary is checked and if tampering is detected
 the program is killed
\end_layout

\end_deeper
\begin_layout Subsubsection
Canaries
\end_layout

\begin_layout Itemize
Terminator canaries: made with terminator characters (typically 
\backslash
0) which cannot be copied by string-copy functions and therefore cannot
 be overwritten
\end_layout

\begin_layout Itemize
Random canaries: random sequence of bytes, chosen when the program is run
\end_layout

\begin_layout Itemize
Random XOR canaries: same as above, but canaries XORed with part of the
 structure that we want to protect
\end_layout

\begin_layout Subsubsection
OS Level Defenses
\end_layout

\begin_layout Itemize
Non-executable stack (Return-to-libc or ROP attack still usable)
\end_layout

\begin_layout Itemize
Address layout randomization (ASLR)
\end_layout

\end_body
\end_document
